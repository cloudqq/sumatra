{"name":"Sumatra","tagline":"Sumatra is a CoffeeScript framework for making beautiful jQuery plugins.","body":"# Sumatra\r\n\r\nSumatra is a CoffeeScript framework for writing jQuery plugins harder,\r\nbetter, faster, stronger.\r\n\r\nYou should use Sumatra if you...\r\n\r\n- Encapsulate complex jQuery plugins in a service object and call an\r\n  instance of that service object for each DOM element the plugin\r\n  selector is passed\r\n- Enjoy test-driven development, clear code, and convention over\r\n  configuration\r\n- Believe unicorns are real\r\n\r\n## Why?\r\n\r\nA lot of jQuery plugins are written to encapsulate a simple bit of\r\nfunctionality used throughout the application. But jQuery's syntax was\r\ndesigned to improve the way people write JavaScript. CoffeeScript has a\r\nsimilar goal, but approaches it from a different angle, it compiles its\r\nsyntax into JavaScript but does so in a safe, syntactically correct and\r\n(mostly) readable way. This framework unites the two, and finally allows\r\njQuery developers to build plugins in CoffeeScript without making their\r\ncode look, well, downright ugly!\r\n\r\n## Installation\r\n\r\nWe recommend Bower for installing Sumatra as a component:\r\n\r\n```bash\r\n$ bower install sumatra\r\n```\r\n\r\nHowever, you can also install Sumatra manually by just including the\r\n`pkg/sumatra.js` file in your javascripts directory.\r\n\r\n## Usage\r\n\r\nSumatra values convention over configuration, and its usage revolves\r\naround an established pattern that hopefully others will find useful.\r\n\r\n### Defining a Basic Plugin\r\n\r\nAfter loading Sumatra, you can build jQuery plugins that are both clear\r\nand superbly terse:\r\n\r\n```coffeescript\r\nsumatra 'clickMe', ->\r\n  class ClickMe extends SumatraPlugin\r\n    action: 'click'\r\n    perform: (event) =>\r\n      element_id = @element.attr('id') || '<div>'\r\n      alert \"You just clicked #{element_id}!\"\r\n```\r\n\r\nAll this plugin does is show an `alert()` when the element is clicked.\r\nYou can define a single action with `action:` and then define the\r\n`perform()` event handler that binds to whatever action you've set\r\non the element.\r\n\r\nTo bind an element to this event, just call it like any normal\r\njQuery plugin:\r\n\r\n```coffeescript\r\n$('#my_element').clickMe();\r\n```\r\n\r\n### Parameters\r\n\r\nYou can also make plugins that pass in options. All Sumatra plugins\r\ntake an `options` hash as their only argument, regardless of whether\r\nthe service object uses them or not.\r\n\r\n```coffeescript\r\nsumatra 'ajaxSubmit', ->\r\n  class AjaxSubmit extends SumatraPlugin\r\n    action: 'submit'\r\n    mergeOptions: ->\r\n      @defaults = @_getFormDefaults()\r\n      _.extend(@options, @defaults)\r\n\r\n    perform: (event) =>\r\n      event.preventDefault()\r\n      event.stopPropagation()\r\n      $.ajax @options\r\n\r\n    _getFormDefaults: ->\r\n      {\r\n        url: @element.attr('action')\r\n        type: @element.attr('method')\r\n        error: (message, status, xhr) ->\r\n          console.log status, message, xhr\r\n          alert \"#{status}: #{message}\"\r\n      }\r\n```\r\n\r\nThis is an example of [ajaxSubmit from the jQuery.form plugin][jqform],\r\nimplemented using Sumatra. It would especially be useful when rendering\r\nan inline response with JSON, using something such as Handlebars to\r\ncompile the JSON data into a logic-less client-side template...\r\n\r\n```coffeescript\r\n$('form').ajaxSubmit \\\r\n  dataType: 'json'\r\n  success: (context) =>\r\n    template = Handlebars.compile $('#response_template')\r\n    response = template(context)\r\n    @element.html response\r\n```\r\n\r\n### Basic Properties\r\n\r\nAs a by-product of the jQuery instantation process, each `SumatraPlugin`\r\ncomes with the following three properties, for free:\r\n\r\n- **@element:** References a single jQuery DOM Object, which can perform\r\n  basic functionality on the page. It is obtained from the collection of\r\n  objects which matched the plugin's selector upon instantiation.\r\n- **@index:** The index of the jQuery DOM Object in the collection of\r\n  objects which matched the plugin's selector upon instantiation.\r\n- **@options:** A Hash-notated Object obtained as the only argument in\r\n  the jQuery plugin when instantiated. This object is then merged with\r\n  the `defaults` hash, which are default params in the plugin's\r\n  definition, before initialization occurs.\r\n\r\n### Workflow\r\n\r\nEach SumatraPlugin has a \"workflow\" that is expressed as a series of\r\nmethods, all run in the `constructor` of the object. The constructor\r\nis responsible for setup of the object's basic properties. This method\r\nshould never be overridden, instead, each step of the instantiation\r\nprocess can be controlled by overriding one of the following methods:\r\n\r\n- **mergeOptions:** Merge the options with the defaults hash. You can\r\n  override this to use attributes from `@element` as defaults instead.\r\n- **initialize:** The main override of the constructor method, this is\r\n  where one would actually \"construct\" the objects they are going to be\r\n  using in this plugin instance, bind events, and call helper methods.\r\n- **bindEvents:** This is where the `action:` event should be bound in\r\n  some way. In many cases, this is overridden to bind other events as\r\n  well as the `action:`, or binding the event as a `$(document).on`.\r\n- **perform:** The event handler of the plugin, this is normally called\r\n  when the `action:` event is fired, but it must be defined if it is\r\n  called or it will throw an error.\r\n\r\nYou can define more methods, but these are the only public methods that\r\nshould be overridden. Any method beginning with `_` is considered\r\n\"private\" and should not be overridden. Please carry this convention\r\nto your own code as well.\r\n\r\n## Development\r\n\r\nYou can build this code into JavaScript by running the following\r\ncommand at the root dir:\r\n\r\n```bash\r\n$ npm install && cake build\r\n```\r\n\r\n### Contributions\r\n\r\nContributions will be accepted via Git/GitHub pull requests, as long as\r\nyou write tests that prove your contributions work. We use Jasmine to\r\nwrite tests in CoffeeScript (you know, for the actual framework?) and\r\nRSpec to write tests for the Rails helpers.\r\n\r\n### Releases\r\n\r\nAll releases will be made in both CoffeeScript and JavaScript, and\r\navailable simultaneously on the Bower and RubyGems package managers.\r\nWe use Bower to manage the standalone JavaScript code which has no\r\ndependency on Sprockets, Rails, or anything Ruby.\r\n\r\nThis code is released under the [MIT License][LICENSE].\r\n\r\n[jqform]: http://jquery.malsup.com/form\r\n[LICENSE]: https://github.com/tubbo/sumatra/blob/master/LICENSE.md\r\n[engine]: http://github.com/tubbo/sumatra-rails\r\n","google":"UA-24749017-3","note":"Don't delete this file! It's used internally to help with page regeneration."}